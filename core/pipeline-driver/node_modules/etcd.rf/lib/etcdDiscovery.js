const Etcd = require('node-etcd');
const EventEmitter = require('events');
const path = require('path');
const { defaults } = require('lodash');
const djsv = require('djsv');

const {
    registerSchema,
    watchSchema,
    initSchema,
    getSchema,
    setSchema
} = require('./schema');
const PREFIX = {
    DISCOVERY: 'discovery',
    SERVICES: 'services'
}

class EtcdDiscovery extends EventEmitter {

    constructor() {
        super();
        this.instanceId = ''
        this.registerSchema = djsv(registerSchema);
        this.watchSchema = djsv(watchSchema);
        this.initSchema = djsv(initSchema);
        this.getSchema = djsv(getSchema);
        this.setSchema = djsv(setSchema);
    }

    /**
     * init data for starting
     * @param {object} options 
     * @param {object} options.etcd contains object for connection {protocol:host:"host ip", port:"port"} 
     * @param {string} options.etcd.protocol protocol http or https 
     * @param {string} options.etcd.host host can be name or ip 
     * @param {integer} options.etcd.port port number 
     * @param {object} options.serviceName the path that will be store on etcd from a const file that contains etcd names 
     * @memberOf etcdDiscovery
     */
    async init(options) {
        let initSchemaConfig = this.initSchema(options);
        if (initSchemaConfig.valid) {
            this._etcdConfigPath = `${initSchemaConfig.instance.etcd.protocol}://${initSchemaConfig.instance.etcd.host}:${initSchemaConfig.instance.etcd.port}`;
            this.etcd = new Etcd(this._etcdConfigPath);
            this._serviceName = initSchemaConfig.instance.serviceName;
            return this;
        } else {
            throw new Error(initSchemaConfig.errorDescription)
        }
    }
    /**
     *  the start method used for begin storing data 
     * @param {object} options 
     * @param {integer}options.ttl  time to live in etcd
     * @param {object} options.data  object that need to be stored in etcd if update is needed use update function
     * @param {number} options.interval  in which interval the store is needed 
     * @param {string} options.serviceName the path that will be store on etcd from a const file that contains etcd names 
     * @param {string} options.instanceId the specific guid the default data is a generated guid
     * 
     * @memberOf EtcdDiscovery
     */
    async register(options) {
        const registerSchemaInstance = this.registerSchema(options);
        if (registerSchemaInstance.valid) {
            let { ttl, interval, data, instanceId } = registerSchemaInstance.instance;
            this._registerPath = path.join('/', PREFIX.DISCOVERY, this._serviceName, instanceId);
            this._ttl = ttl;
            this._interval = interval;
            this._data = data;
            this._runInterval();
        } else {
            throw new Error(registerSchemaInstance.errorDescription);
        }
    }

    /**
     *  the start method used for begin storing data 
     * @param {object} options 
     * @param {object} options.data  object that need to be stored in etcd if update is needed use update function
     * @param {string} options.serviceName the path that will be store on etcd if not assigned than it gets the one from the init
     * @param {string} options.instanceId the specific guid the default data is a generated guid
     * @param {string} options.postfix postfix can be service or discovery or just ''
     * @memberOf EtcdDiscovery
     */
    async set(options) {
        const setSchemaInstance = this.setSchema(options, { ignoreNull: true });
        if (setSchemaInstance.valid) {
            if (!setSchemaInstance.instance) {
                console.log('here');
            }
            let { data, instanceId, serviceName, postfix } = setSchemaInstance.instance;
            let internalServiceName = serviceName ? serviceName : this._serviceName
            let _path = path.join('/', PREFIX.SERVICES, internalServiceName, instanceId, postfix);
            this._data = data;
            try {
                return await this._keyRegister(_path, null);
            } catch (error) {
                throw new Error(error)
            }
        } else {
            throw new Error(setSchemaInstance.errorDescription);
        }
    }
    /**
     * pausing interval 
     * @memberOf EtcdDiscovery
     */
    pause() {
        clearTimeout(this._intervalID);
    }
    /**
     * resuming paused interval
     * @memberOf EtcdDiscovery
     */
    resume() {
        this._runInterval();
    }
    async _runInterval() {
        //  let _etcdPath = etcdPath;
        this._intervalID = setTimeout(async () => {
            try {
                await this._keyRegister(this._registerPath, this._ttl)
                this._runInterval();
            } catch (error) {
                this.emit(`etcd - error`, error)
            }
        }, this._interval);
    }
    /**
     * updating data for the current path 
     * @param {Object} data the updated date {}
     * @memberOf etcdDiscovery
     */
    updateRegisteredData(data) {
        this._data = data;
    }


    /**
     * get the current messages returns object with the current value and watch object
     * 
     * @param {object} options 
     * @param {string} options.serviceName the path that will be store on etcd from a const file that contains etcd names 
     * @param {string} options.instanceId the specific guid the default data is a generated guid
     * @param {string} options.prefix prefix can be service or discovery or just ''
     * @param {string} options.postfix postfix can be service or discovery or just ''
     * @param {any} options.etcdOptions etcd options the default is  {wait: true}
     * @param {bool}options.etcdConfig.recursive (bool, list all values in directory recursively)
     * @param {bool}options.etcdConfig.wait (bool, wait for changes to key)
     * @param {integer}options.etcdConfig.waitIndex (wait for changes after given index)

     * 
     * @memberOf EtcdDiscovery
     */

    get(options) {
        return new Promise((res, rej) => {
            const getSchemaInstance = this.getSchema(options, { ignoreNull: true });
            if (getSchemaInstance.valid) {
                let { serviceName, instanceId, index, etcdOptions, postfix } = getSchemaInstance.instance;
                let internalServiceName = serviceName ? serviceName : this._serviceName
                let _path = path.join('/', PREFIX.SERVICES, internalServiceName, instanceId, postfix);
                this.etcd.get(_path, etcdOptions, (err, obj) => {
                    if (err) {
                        return rej(err)
                    }
                    return res(obj)
                });
            } else {
                return rej(getSchemaInstance.errorDescription);
            }
        });
    }



    /**
     * watch notification for messages returns object with the current value and watch object
     * that can be used as follows 
     * watcher.on('change'/'expire'/'delete',data => {
     *    console.log('Value changed; new value: ', node);
     *   })
     * @param {object} options 
     * @param {string} options.serviceName the path that will be store on etcd from a const file that contains etcd names 
     * @param {string} options.instanceId the specific guid the default data is a generated guid
     * @param {any} options.etcdOptions etcd options the default is  {wait: true}
     * @param {bool}options.etcdConfig.recursive (bool, list all values in directory recursively)
     * @param {bool}options.etcdConfig.wait (bool, wait for changes to key)
     * @param {integer}options.etcdConfig.waitIndex (wait for changes after given index)

     * @memberOf EtcdDiscovery
     */
    async watch(options) {
        return new Promise((res, rej) => {
            const watchSchemaInstance = this.watchSchema(options, {
                ignoreNull: true
            });
            if (watchSchemaInstance.valid) {
                let { serviceName, instanceId, index, etcdOptions } = watchSchemaInstance.instance;
                let internalServiceName = serviceName ? serviceName : this._serviceName
                let _path = path.join('/', PREFIX.DISCOVERY, internalServiceName, instanceId);
                this.etcd.get(_path, {}, (err, obj) => {
                    let watcher = this.etcd.watcher(_path, index, etcdOptions)
                    if (err) {
                        if (err.errorCode == 100) {
                            return res({ obj: {}, watcher });
                        } else {
                            return rej(err)
                        }
                    }
                    return res({ obj, watcher });
                });
            } else {
                return rej(watchSchemaInstance.errorDescription);
            }
        });
    }

    async _keyRegister(etcdPath, ttl) {
        return new Promise((resolve, reject) => {
            this.etcd.set(etcdPath,
                JSON.stringify({
                    data: this._data
                }),
                { ttl }, (err, res) => {
                    if (err) {
                        return reject(err);
                    }
                    return resolve(res)
                    // console.log(`${res} - saved`)
                })
        });
    }



}

module.exports = EtcdDiscovery;