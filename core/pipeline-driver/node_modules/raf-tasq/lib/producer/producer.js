const EventEmitter = require('events');
const Queue = require('bull');
const validate = require('djsv');
const schema = require('./schema');
const helper = require('../helpers/helper');

class Producer extends EventEmitter {

    constructor(options) {
        super();
        this._setting = Object.assign({}, options.setting);
        const res = validate(schema.properties.setting, this._setting);
        if (!res.valid) {
            throw new Error(res.errors[0].stack);
        }
        this._jobMap = new Map();
        this._queue = new Queue(this._setting.queueName, this._setting);
        this._queue.on('global:waiting', (jobs, type) => {
            this.emit('job-waiting', jobs, type); // TODO
        }).on('global:active', (jobID, jobPromise) => {
            const job = this._getJob(jobID);
            if (job && job.options.resolveOnStart) {
                this._tryResolve(job);
            }
            this.emit('job-active', jobID);
        }).on('global:failed', (jobID, err) => {
            const job = this._getJob(jobID);
            if (job) {
                clearTimeout(job.timeout);
                this._jobMap.delete(job.id);
                job.reject(err);
            }
            this.emit('job-failed', jobID, err);
        }).on('global:completed', (jobID, result) => {
            result = helper.tryParseJSON(result);
            const job = this._getJob(jobID);
            if (job && job.options.resolveOnComplete) {
                this._tryResolve(job, result);
            }
            this.emit('job-completed', jobID, result);
        }).on('global:error', (error) => {
            this.emit('job-error', error);
        });
    }

    createJob(options) {
        return new Promise((resolve, reject) => {
            options = options || {};
            const res = validate(schema, options);
            if (!res.valid) {
                return reject(new Error(res.errors[0].stack));
            }
            this._queue.add(options.job.type, options.job.data, options.queue).then((job) => {
                let timer;
                const jobID = helper.jobKey(this._setting.queueName, this._setting.prefix, job.id);
                if (options.job.waitingTimeout > 0) {
                    timer = setTimeout(() => {
                        job.discard();
                        job.remove();
                        this._jobMap.delete(job.id);
                        return reject(new Error(`job-waiting-timeout (id: ${job.id})`));
                    }, options.job.waitingTimeout);
                }
                if (!options.job.resolveOnStart && !options.job.resolveOnComplete) {
                    return resolve(jobID);
                }
                else {
                    this._jobMap.set(jobID, {
                        id: job.id,
                        key: jobID,
                        timeout: timer,
                        resolve: resolve,
                        reject: reject,
                        options: options.job
                    });
                }
            }).catch((error) => {
                return reject(error);
            });
        })
    }

    async getJob(options) {
        return await this._queue.getJob(options.jobID);
    }

    _getJob(jobID) {
        return this._jobMap.get(helper.jobKey(this._setting.queueName, this._setting.prefix, jobID));
    }

    _tryResolve(job, result) {
        clearTimeout(job.timeout);
        this._jobMap.delete(job.id);
        job.resolve({ jobID: job.id, result: result });
    }
}

module.exports = Producer;